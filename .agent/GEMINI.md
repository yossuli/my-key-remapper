# my-key-remapper プロジェクト固有のナレッジ

## プロジェクト概要

- **タイプ**: Electron + React アプリケーション
- **目的**: キーリマッパー（キーボードの入力を別のキーにリマップ）
- **言語**: TypeScript

## アーキテクチャ

### ディレクトリ構造

```
src/
├── main/           # Electron メインプロセス
│   ├── hook/       # キーボードフック・イベント処理
│   ├── ipc/        # IPC通信ハンドラ
│   ├── native/     # koffi FFIバインディング・キー送信
│   ├── state/      # 状態管理（RemapRules, KeyState, LayerState）
│   ├── storage/    # 設定永続化
│   └── utils/      # ユーティリティ
├── preload/        # Electron プリロード（IPC bridge）
├── renderer/       # React フロントエンド (Atomic Design)
│   └── src/
│       ├── components/
│       │   ├── atoms/      # 7コンポーネント
│       │   ├── molecules/  # 7コンポーネント
│       │   ├── organisms/  # 5コンポーネント
│       │   ├── template/   # 3コンポーネント
│       │   ├── pages/      # 1コンポーネント
│       │   └── control/    # 7コンポーネント（宣言的条件分岐用）
│       ├── hooks/          # 11カスタムフック
│       ├── utils/          # 9ユーティリティ関数
│       └── types/          # フロントエンド専用型
└── shared/         # 共有コード
    ├── constants/  # VKコード、キーボードレイアウト定義
    └── types/      # 共有型定義（TriggerType, Action, Layer等）
```

### コーディング規約

- **Ultracite/Biome**: `biome.jsonc` で設定済み
  - `ultracite/core` と `ultracite/react` を継承
  - `biome-ignore` は禁止（ユーザー許可が必要）
- **コメント**: すべて日本語で記述
- **関数**: 明示的な戻り値の型を付ける
- **ファイル名**: camelCase
- **インポート**: 相対パス（`../../`）よりもエイリアス（`@/`）を使用する。
- **Props Inline Destructuring**: 特に理由がない限り、コンポーネントの引数内で分割代入を行うこと。
- **tree/ ディレクトリ**: 円滑な移行のために作成された一時的なディレクトリ。基本的にここへの**新規追加は禁止**し、既存の定義も順次適切な場所へ移動させて最終的には廃止することを目指す。

### UI/UX デザインパターン

- **選択 UI**: 選択肢が少ない（3〜4 個以下）場合は、ドロップダウン（Select）ではなく**Segmented Control（ボタン列）**を採用し、ワンクリックで切り替え可能にする。
- **数値入力**: 座標（X, Y）などの関連する数値ペアは、ラベルを極力省き、横並びでコンパクトに配置する。
- **主要ボタン**: アイコン + テキストの組み合わせを基本とし、視認性を高める。

### 設計思想 (Architecture Decisions)

- **Props Grouping**:

  - 関連する Props（State と Actions など）は、親コンポーネントから中間コンポーネントへは**オブジェクトのまま（グループ化して）**渡す。
  - **目的（可読性・効率）**: 中間層の Props 定義を簡潔に保ちつつ、バケツリレー（Prop Drilling）のメンテナンスコストを低減するため。
  - ※ 分割代入の実装ルールについては、コーディング規約の「Props Inline Destructuring」を参照。

  - ✅ **適用すべき**: 中間コンポーネントを経由する場合（Prop Drilling が発生する場合）
  - ❌ **不要**: 親から直接子へ渡す場合（即座に使用される場合）
  - 理由: 親でグループ化して子で即座に分解するのは無駄な処理であり、可読性の向上にも寄与しない。

- **Context API の不採用**:
  - 状態共有の手段として Context API は使用せず、**Prop Grouping** によってバケツリレーを管理可能なレベルに保つ。
  - Drilling が深刻な場合は、グループの粒度を見直すか、Hooks への抽出を検討する。

## よくある修正リスト (Common Fixes)

詳細な手順は `.agent/workflows/` ディレクトリ内の各ファイルに定義されています。
私が「よくある修正リストを出して」と指示した際は、このディレクトリを確認し、リストを提示してどれを実行するか尋ねてください。

- **[Workflow-000] 普遍的な知見のルール化**: 作業中に発見した有用な知見やパターンをドキュメント化し、ナレッジとして蓄積する手順。 (`.agent/workflows/000.md`)
- **[Workflow-001] Prop Grouping の型定義配置の修正**: 親子間の Props 受け渡しにおける型定義の場所を最適化し、トレーサビリティを向上させる。 (`.agent/workflows/001.md`)
- **[Workflow-002] スプレッド演算子を使った分割代入でのグループ化**: 呼び出し側でスプレッド演算子を使い、必要な値だけを取り出して残りを自動的にグループ化することで、中間オブジェクト生成を省略する。 (`.agent/workflows/002.md`)
- **[Workflow-003] 適切なコミット粒度とメッセージの規約**: 原則として一括ステージングを避け、論理的な変更単位でコミットを行う手順。 (`.agent/workflows/003.md`)
- **[Workflow-004] Props 分割代入 (Inline Destructuring)**: Props Grouping ルールに基づき、コンポーネントの引数内で Props を分割代入し、可読性と依存関係の明示性を向上させる手順。 (`.agent/workflows/004.md`)
- **[Workflow-005] Props Grouping の適用判断**: Props をグループ化すべきか個別に渡すべきかの判断基準と、適切な適用方法。 (`.agent/workflows/005.md`)
- **[Workflow-006] スプレッド分割代入後の型定義の再配置**: スプレッド演算子によるグループ化を適用した後、親で不要になった型定義を、その Props を受けるメインの子コンポーネントへ移動する手順。 (`.agent/workflows/006.md`)
- **[Workflow-007] カリー化による Prop 渡しの簡略化**: 特定の引数を固定した関数を返す（カリー化）ことで、Props に渡す際の記述を簡潔にする手順。 (`.agent/workflows/007.md`)
- **[Workflow-008] 制御コンポーネントによる宣言的な条件付きレンダリング**: 三項演算子の代わりに `With` コンポーネント等を使用して、宣言的に条件付きレンダリングを行う手順。 (`.agent/workflows/008.md`)
- **[Workflow-009] データパス指向のプロップスフロー可視化とリファクタリング**: プロップス伝播表を「データ経路」で分割して可視化し、Drill の行き止まりを排除しつつリファクタリングを行う手順。 (`.agent/workflows/009.md`)

## ドメイン知識・注意点 (Domain Knowledge)

### キーイベント処理

- アクションは指定されたトリガーを確認後、'tap' トリガーにフォールバック
- すべてのレイヤーを統一的に扱う（base レイヤーの特別扱いなし）
- リマップが定義されていない場合はデフォルトのキー動作を維持

### パフォーマンス優先のリファクタリング方針

- キーイベント処理（`src/main/hook`）は速度が最優先
- 再利用しない限り、認知的複雑度を減らす目的だけでの関数分割は不要
- 再利用する場合のみ関数化を行う
- 速さ優先で `let` を使用したループ内変数書き換えも許容

### Double Tap 検出

- `onKeyUp` で即座に "tap" を返すと、ダブルタップ検出に失敗する
- `tapIntervalMs` 内での 2 回目のタップを待つ必要がある

### 動作確認

- このアプリは私（Claude）が起動しても何も起きないため、動作確認はしない
- ビルド成功のみを検証する

---

## 承認プロセス (Approval Process)

- **計画と実行の分離**:
  - コーディング作業を行う際は、必ず「計画」と「実行」を明確に分けてください。
  - 計画（ログファイルへの記述含む）を提示した後、**私が「やって」や「OK」と明示的に許可を出すまで、コードの変更作業（`write_to_file`, `replace_file_content`等）を開始してはいけません。**
  - 「計画を立てろ」という指示に対して、計画作成と同時に実装まで完了させてはいけません。
- **指示の解釈**:
  - 「チャットに書くな」等の指示は、出力場所の変更指示であり、承認プロセスの省略指示ではありません。
  - 判断に迷う場合は、実装に進む前に必ず確認してください。

---

_このファイルは作業中に学んだことや間違いを記録するために更新されます_
