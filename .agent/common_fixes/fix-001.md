# [Fix-001] Prop Grouping の型定義配置の修正

## 概要

コンポーネント間で関連する Props をオブジェクトにまとめて渡す「Prop Grouping」パターンにおいて、型定義の配置場所と型注釈の方法を最適化し、開発体験（DX）と保守性を向上させる修正パターンです。

## 状況・課題

親コンポーネントでオブジェクトを作成して子に渡しているが、以下の問題がある。

1. **型注釈の欠如**: 型推論に依存しており、意図しないプロパティが含まれても定義時点でエラーにならない。
2. **型定義の散逸**: 型定義が `src/types/` など遠くのファイルにあり、コンポーネントとの関連性が見えにくい。
3. **トレーサビリティの低下**: IDE で「参照の検索」をした際、生成元と利用元が直接結びつかず、追跡が困難。

### Bad Example

```typescript
// Parent.tsx
// 型注釈がないため、ただのオブジェクトとして扱われる
const actions = {
  add: () => {},
  remove: () => {},
};

return <Child actions={actions} />;

// Child.tsx
// 型定義のためにわざわざ別ファイルを import したり、手書きで型定義している
import { Actions } from "@/types/global";
```

## 修正内容 (Step-by-Step)

### 1. 型定義のコロケーション (Co-location)

オブジェクトを生成するコンポーネントファイル（親）の内部で型を定義し、`export` する。
元のデータがカスタムフック由来の場合は、`ReturnType` や `Pick` を活用して同期を保つ。

```typescript
// Parent.tsx
import { useSomething } from "@/hooks/useSomething";

// フックの戻り値から必要な型を抽出して定義
// これにより、フックの実装が変わればここも自動的に追従する
export type SomeActions = Pick<
  ReturnType<typeof useSomething>,
  "add" | "remove"
>;

export function Parent() {
  const { add, remove } = useSomething();

  // 2. 明示的な型注釈
  // ここで定義と実体の整合性が保証される
  const actions: SomeActions = {
    add,
    remove,
  };

  return <Child actions={actions} />;
}
```

### 2. 子コンポーネントでのインポート

子コンポーネントは、親コンポーネントから直接型をインポートする。

```typescript
// Child.tsx
// 親（生成元）から型を借りる
import type { SomeActions } from "./Parent";

interface ChildProps {
  actions: SomeActions;
}

export function Child({ actions }: ChildProps) { ... }
```

## メリット

1. **定義時点での安全性**: 親コンポーネントでオブジェクトを作る瞬間に、プロパティの過不足や型間違いを検知できる。
2. **強力なトレーサビリティ**: IDE で `SomeActions` を「参照の検索」すれば、誰がこれを使っているか（子コンポーネント）が一発で分かる。逆に子から親へ定義ジャンプも容易。
3. **変更への強さ**: フックの実装変更 -> 親の型定義 -> 親の実装 -> 子の利用箇所、という依存チェーンが型システムによって守られる。

## チェックリスト

- [ ] オブジェクト生成変数に型注釈がついているか？ (`const obj: Type = { ... }`)
- [ ] 型定義は同じファイル内にあるか？
- [ ] 型定義は `export` されているか？
- [ ] 外部フック由来の場合、`Pick<ReturnType<...>>` などを使って同期されているか？
- [ ] 子コンポーネントは親から型を `import` しているか？
