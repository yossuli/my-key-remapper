---
description: スプレッド演算子を使った分割代入でのグループ化
---

# [Workflow-002] スプレッド演算子を使った分割代入でのグループ化

## 概要

提供元（カスタムフック、関数、モジュール等）から個別に取得した値を、呼び出し側で再度オブジェクトにまとめるという冗長なパターンを解消します。**スプレッド演算子 (`...`) を分割代入と組み合わせることで、必要な値だけを取り出し、残りを自動的にグループ化**できます。

このパターンは以下のような場面で適用できます:

- **カスタムフック**: 状態と操作関数を分離したい場合
- **関数の戻り値**: 一部の値だけ個別に使い、残りをまとめたい場合
- **オブジェクトの分解**: 特定のプロパティだけ取り出し、残りを保持したい場合

## 課題

### Bad Example 1: カスタムフック

```typescript
// カスタムフック
export function useRemapControl() {
  const [isActive, setIsActive] = useState(false);

  const toggleActive = () => setIsActive(!isActive);
  const enableRemap = () => setIsActive(true);
  const disableRemap = () => setIsActive(false);

  return {
    isActive,
    toggleActive,
    enableRemap,
    disableRemap,
  };
}

// 呼び出し側
const { isActive, toggleActive, enableRemap, disableRemap } = useRemapControl();

// 再度オブジェクトにまとめる（冗長!）
const remapActions: RemapActions = {
  toggleActive,
  enableRemap,
  disableRemap,
};
```

### Bad Example 2: レイヤー状態管理

```typescript
// カスタムフック
export function useLayerState() {
  const [layers, setLayers] = useState([]);
  const [layerId, setLayerId] = useState(0);

  const setLayerId = (id: number) => {
    /* ... */
  };
  const addLayer = () => {
    /* ... */
  };
  const removeLayer = () => {
    /* ... */
  };
  const reorderLayers = () => {
    /* ... */
  };

  return {
    layers,
    layerId,
    setLayerId,
    addLayer,
    removeLayer,
    reorderLayers,
  };
}

// 呼び出し側
const { layers, layerId, setLayerId, addLayer, removeLayer, reorderLayers } =
  useLayerState();

// 再度オブジェクトにまとめる（冗長!）
const layerState: LayerState = { layers, layerId };
const layerActions: LayerActions = {
  setLayerId,
  addLayer,
  removeLayer,
  reorderLayers,
};
```

### 問題点

1. **冗長性**: 個別に取り出した値を再度オブジェクトにまとめている
2. **保守性**: プロパティ追加時に複数箇所の修正が必要
3. **可読性**: 何が個別に使われ、何がグループ化されるかが分かりにくい

## 解決策

### Good Example 1: カスタムフック

```typescript
// カスタムフック（変更不要）
export function useRemapControl() {
  const [isActive, setIsActive] = useState(false);

  const toggleActive = () => setIsActive(!isActive);
  const enableRemap = () => setIsActive(true);
  const disableRemap = () => setIsActive(false);

  return {
    isActive,
    toggleActive,
    enableRemap,
    disableRemap,
  };
}

// 呼び出し側: スプレッド演算子で残りをまとめる
const { isActive, ...remapActions } = useRemapControl();
// isActive は個別に使える
// remapActions = { toggleActive, enableRemap, disableRemap }
```

### Good Example 2: レイヤー状態管理

```typescript
// カスタムフック（変更不要）
export function useLayerState() {
  const [layers, setLayers] = useState([]);
  const [layerId, setLayerId] = useState(0);

  const setLayerId = (id: number) => {
    /* ... */
  };
  const addLayer = () => {
    /* ... */
  };
  const removeLayer = () => {
    /* ... */
  };
  const reorderLayers = () => {
    /* ... */
  };

  return {
    layers,
    layerId,
    setLayerId,
    addLayer,
    removeLayer,
    reorderLayers,
  };
}

// 呼び出し側: 状態とアクションを分離
const { layers, layerId, ...layerActions } = useLayerState();

const layerState = { layers, layerId };
// layerActions = { setLayerId, addLayer, removeLayer, reorderLayers }
```

### Good Example 3: 複数のグループに分ける

```typescript
// 複数の値を個別に取り出し、残りをグループ化
const {
  layers,
  layerId,
  currentBindings,
  saveMapping,
  removeMapping,
  ...layerActions
} = useLayerState();

const layerState = { layers, layerId };
const mappingActions = { saveMapping, removeMapping };
// layerActions = { setLayerId, addLayer, removeLayer, reorderLayers }
```

## 手順 (Step-by-Step)

### 1. 現在のコードを分析

- 個別に分割代入している箇所を特定
- その後に再度オブジェクトにまとめている箇所を探す

### 2. グループ化の方針を決定

- **個別に使う値**: コンポーネント内で直接参照する値
- **グループ化する値**: Props として子コンポーネントに渡す値

### 3. スプレッド演算子を使った分割代入に変更

**Before:**

```typescript
const { a, b, c, d } = useHook();
const group = { c, d };
```

**After:**

```typescript
const { a, b, ...group } = useHook();
```

### 4. 型定義の確認

スプレッド演算子で取得したオブジェクトの型が正しいか確認します。

```typescript
// 型定義が必要な場合
type RemapActions = Omit<ReturnType<typeof useRemapControl>, "isActive">;

const { isActive, ...remapActions } = useRemapControl();
// remapActions の型は自動的に推論される
```

通常は型推論で十分ですが、明示的な型が必要な場合は `Omit` や `Pick` を使います。

### 5. 動作確認

- ビルドが成功するか確認
- グループ化された値が正しく子コンポーネントに渡されるか確認

## チェックリスト

- [ ] 個別に分割代入して再度まとめている箇所を特定したか?
- [ ] どの値を個別に使い、どの値をグループ化するか決定したか?
- [ ] スプレッド演算子を使った分割代入に変更したか?
- [ ] 型定義が正しいか確認したか?
- [ ] ビルドが成功するか確認したか?
- [ ] グループ化された値が意図した形で使用できるか確認したか?

## 関連ワークフロー

- [Workflow-004] Leaf コンポーネントでの Props 分割代入 (Late Destructuring)
- [Workflow-005] Props Grouping の適用判断

## 注意点

### スプレッド演算子の順序

スプレッド演算子は**最後**に配置する必要があります:

```typescript
// ✅ 正しい
const { a, b, ...rest } = obj;

// ❌ エラー
const { ...rest, a, b } = obj;
```

### 型の明示が必要な場合

TypeScript が型を正しく推論できない場合は、明示的に型を指定します:

```typescript
type RemapActions = Omit<ReturnType<typeof useRemapControl>, "isActive">;
const { isActive, ...remapActions }: { isActive: boolean } & RemapActions =
  useRemapControl();
```

ただし、通常は型推論で十分なため、明示的な型指定は不要です。

## 知見の種 (Seed) の記録

運用を通じて得られた「コーディングパターンの改善案」や「ルールの例外事例」は、`seeds.md` (Working Dir) へ記録してください（[Workflow-seed] 準拠）。

## 知見の継続的改善 (Continuous Knowledge Improvement)

このワークフローを使用する中で、新しい指示や改善点が見つかった場合は、必ずこのファイル (`.agent/workflows/002.md`) を更新・改善することを提案してください。
