---
description: Props Grouping の適用判断
---

# [Workflow-005] Props Grouping の適用判断

## 概要

Props Grouping（関連する Props をオブジェクトにまとめて渡す手法）は、Prop Drilling を削減し、中間コンポーネントの Props 定義を簡潔にする有効な手法です。しかし、**すべての場合に適用すべきではありません**。

このワークフローでは、Props Grouping を適用すべきケースと、個別 Props のまま渡すべきケースの判断基準を示します。

## 判断基準

### ✅ Props Grouping を適用すべきケース

**条件**: 中間コンポーネントを経由する場合（Prop Drilling が発生する場合）

```
Parent (定義) → Middle (通過) → Child (使用)
```

**メリット**:

- 中間コンポーネントの Props 定義が簡潔になる
- 関連する Props の追加・削除が容易
- Props の関連性が明確になる

### ❌ Props Grouping が不要なケース

> [!IMPORTANT] > **親から子へ直接渡す場合（Prop Drilling が発生しない場合）は、Props Grouping は不要です。**
> 将来の拡張性を懸念して過剰に Grouping することは避けてください。直下の手渡しが最も可読性が高いためです。
> **YAGNI 原則（You Aint Gonna Need It）** を遵守しましょう。

**条件**: 親から直接子へ渡す場合（即座に使用される場合）

```
Parent (定義) → Child (使用)
```

**理由**:

- 親でグループ化して子で即座に分解するのは無駄な処理
- 可読性の向上にも寄与しない
- Props の型定義が冗長になる

## Bad/Good Example

### ❌ Bad: 直接渡しなのにグループ化

```typescript
// Parent.tsx
export type LayerState = { layers: Layer[]; layerId: string };

function Parent() {
  const layers = useLayers();
  const layerId = useLayerId();
  const layerState: LayerState = { layers, layerId };

  return <Child layerState={layerState} />;
}

// Child.tsx (直接使用する末端コンポーネント)
function Child({ layerState }: { layerState: LayerState }) {
  const { layers, layerId } = layerState; // 即座に分解
  // layers と layerId を使用...
}
```

**問題点**:

- `Parent` でグループ化 → `Child` で即座に分解という無駄な処理
- 型定義 `LayerState` が余計に必要

### ✅ Good: 直接渡しは個別 Props

```typescript
// Parent.tsx
function Parent() {
  const layers = useLayers();
  const layerId = useLayerId();

  return <Child layers={layers} layerId={layerId} />;
}

// Child.tsx
function Child({ layers, layerId }: { layers: Layer[]; layerId: string }) {
  // layers と layerId を直接使用...
}
```

### ✅ Good: 中間経由はグループ化

```typescript
// Parent.tsx
export type LayerState = { layers: Layer[]; layerId: string };

function Parent() {
  const layers = useLayers();
  const layerId = useLayerId();
  const layerState: LayerState = { layers, layerId };

  return <Middle layerState={layerState} />;
}

// Middle.tsx (通過するだけ)
function Middle({ layerState }: { layerState: LayerState }) {
  return <Child layerState={layerState} />;
}

// Child.tsx (末端で分解)
function Child({ layerState }: { layerState: LayerState }) {
  const { layers, layerId } = layerState;
  // layers と layerId を使用...
}
```

**メリット**:

- `Middle` の Props 定義が簡潔（`layerState` のみ）
- `layers` や `layerId` の追加・削除時に `Middle` の変更が不要

## 手順

### 1. Props の伝播経路を確認

コンポーネント間の Props の流れを確認します。

```
Parent → Child (直接)
Parent → Middle → Child (経由)
Parent → A → B → C (多段経由)
```

### 2. 判断基準の適用

- **直接渡し**: 個別 Props を使用
- **中間経由**: Props Grouping を適用

### 3. 既存コードの見直し

不適切なグループ化を発見した場合:

1. Props の使用箇所を確認
2. 中間コンポーネントが存在するか確認
3. **重要**: 親から直下の子への渡しの場合は、グループ化を解除して個別 Props に戻すことを検討する。

### 4. 型定義の整理

- グループ化を解除する場合: 不要になった型定義を削除
- グループ化を適用する場合: 親コンポーネントで型定義を作成

## チェックリスト

- [ ] Props の伝播経路を確認したか？
- [ ] **直下の子コンポーネントへの渡しでないか確認したか？（直下なら Grouping 不要）**
- [ ] 中間コンポーネントが存在するか確認したか？
- [ ] 判断基準に基づいて適切な形式を選択したか？
- [ ] 不要な型定義を削除したか？
- [ ] `npm run typecheck` でエラーがないか確認したか？

## 参考

- `.agent/GEMINI.md` の「設計思想 (Architecture Decisions)」セクション
- `props_flow.md` の Props 伝播マトリクス

## 知見の種 (Seed) の記録

運用を通じて得られた「コーディングパターンの改善案」や「ルールの例外事例」は、`seeds.md` (Working Dir) へ記録してください（[Workflow-seed] 準拠）。

## 知見の継続的改善 (Continuous Knowledge Improvement)

このワークフローを使用する中で、新しい指示や改善点が見つかった場合は、必ずこのファイル (`.agent/workflows/005.md`) を更新・改善することを提案してください。
