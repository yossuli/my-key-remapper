---
description: 大規模機能の実装計画策定ガイドライン
---

# [Workflow-010] 大規模機能の実装計画策定 (High-Quality Feature Planning)

## 概要

新機能や大規模なリファクタリングの実装計画を立てる際、後戻りを防ぎ、スムーズな実装とレビューを実現するためのガイドラインです。
単なるタスクリストではなく、**「これを見れば最終的にどうなるかが完全に理解できる（Source of Truth）」**レベルの計画書を作成することを目的とします。

## 重要な構成要素 (The "Must-Haves")

実装計画書 (`implementation_plan.md`) には、必ず以下の要素を含めてください。

### 0. 完全性・自己完結性 (Completeness & Context) [重要]

修正や追記を行う際、**既存の記述を「(中略)」などで省略してはいけません。**

- **No Abbreviations**: 計画書は常に完全な状態（Full Version）を維持してください。過去のチャット履歴やドキュメントの更新履歴を遡らなくても、そのファイル単体ですべての仕様が把握できるようにします。
- **Single Source of Truth**: コードスニペットや仕様が重複しても構いません。計画書が常に最新かつ完全な仕様書であることを保証してください。

### 1. 具体的コードスニペット (Concrete Code Snippets)

自然言語の説明だけでなく、実際のコードの断片を必ず含めてください。

- **データ構造**: 定義する型（Interface/Type）、データベーススキーマ、State の形状。
- **ロジック**: 複雑なアルゴリズム、状態遷移、非同期処理のフロー（擬似コード可）。
- **インターフェース**: 公開関数のシグネチャ、API のエンドポイント定義。

### 2. 詳細な UI/UX 設計 (UX/UI Specification)

図
「画面を作る」という記述だけでなく、具体的なインタラクションと構成を定義します。

- **画面遷移**: モーダル、ドリルダウン、タブ切り替えなどの構造。
- **状態定義**: Loading, Error, Empty などのエッジケース。
- **インタラクション**: ドラッグ＆ドロップ、ショートカットキー、バリデーションの挙動。
- **ライブラリ選定**: 使用する既存ライブラリやコンポーネントの明記。
- **ワイヤーフレーム**: ASCII アートや Mermaid 図を用いて、画面レイアウトを可視化する。

### 2.5. 複雑性の可視化 (Visualizing Complexity with Mermaid & ASCII)

テキストやコードスニペットだけでは伝わりにくい複雑なロジックや依存関係は、図を用いて可視化してください。
基本的には **Mermaid** を使用しますが、**Mermaid のレイアウト制御が難しい場合（わかりやすくするために特定の並び順の強制、コンパクト化、パースエラーの回避など）は、迷わず ASCII アート（テキスト図）を使用してください。** ASCII アートはレイアウトの自由度が最も高く、意図した配置を確実に表現できます。

> [!TIP] > **アーキテクチャ図解のベストプラクティス**
> Mermaid 図を作成する際は、可読性と正確性を高めるための詳細なガイドライン `[Workflow-012] Effective Architectural Visualization` (.agent/workflows/012.md) を参照してください。（脱クラス図、ダークモード対応など）

目的に応じて、以下の「Micro（ロジック）」と「Macro（構造）」の視点を使い分け、あるいは組み合わせます。

#### A. ロジックと時間の流れ (Micro View)

**目的**: 複雑な条件分岐、非同期処理、ユーザー操作に対する一連の反応を整理する。

- **状態遷移図 / フローチャート (Flowchart / State Diagram)**
  - `flowchart TD` または `stateDiagram-v2` を使用。
  - **使用例**:
    - キー入力の判定ロジック（Tap vs Hold）。
    - タイマーやイベントリスナーの開始・終了フロー。
    - API 通信の状態変化（Idle -> Loading -> Success/Error）。

#### B. 構造とデータの流れ (Macro View)

**目的**: コンポーネントの配置、データの所有権、依存関係を整理する。

- **構造・依存関係図 (Structure / Dependency Graph)**
  - `flowchart TB` または `classDiagram` を使用。
  - **使用例**:
    - 新しいフックやコンポーネントが既存システムのどこに配置されるか。
    - 親子コンポーネント間の Props フローや、カスタムフックの所有関係。
    - グローバルイベント（Window）とコンポーネントの接点。

#### C. 相互作用 (Interaction View)

**目的**: 複数のレイヤー（UI, Logic, Main Process）にまたがる処理フローを時系列で追う。

- **シーケンス図 (Sequence Diagram)**
  - `sequenceDiagram` を使用。
  - **使用例**:
    - IPC 通信（Renderer <-> Main）の往復。
    - ユーザーアクションから DB 保存までのフルスタックな流れ。

**メリット**:

- **レビュー効率向上**: テキストを読み解く負荷を下げ、構造を一目で共有できる。
- **自己検閲**:「この矢印はどこにも繋がっていない」といった論理的欠陥（"Bad" Pattern）に実装前で気づける。

### 3. アーキテクチャと関心の分離 (Architecture & Separation)

実装の簡便さよりも、長期的な保守性と拡張性を優先した設計を行います。

- **正規化 (Normalization)**: データの実体（Definition）と参照（Reference）を分離し、データの重複を防ぐ（例：ID 参照モデル）。
- **責務の分離**: データ管理、ビジネスロジック、UI 表示を適切なレイヤーやコンポーネントに分割する。
- **エディタの独立**: 複雑なオブジェクトの編集は、インラインではなく専用の管理画面（Manager）や独立したエディタに切り出すことを検討する。

### 4. 実行モデルと副作用 (Execution & Side Effects)

- **同期/非同期の明確化**: 処理がブロッキングか、非同期（Fire-and-forget / Promise 待機）かを明記する。
- **エラーハンドリング**: 失敗時の挙動（ロールバック、ユーザー通知、ログ出力）を定義する。

---

## 計画策定プロセス (Process)

1.  **要件の構造化**: 自然言語の要件を、システム上のエンティティとアクションに分解する。
2.  **型定義**: まずデータ構造（型）を書き下す。これが全ての土台となる。
3.  **UI フローの可視化**: ユーザーがどう操作し、データがどう変化するかをシミュレーションする。
4.  **「Bad」の排除**: 密結合、循環参照、過度なネストなど、設計上のアンチパターンがないか自問する。
5.  **レビュー**: 作成した計画をユーザーに提示し、フィードバックを得て修正する。

## チェックリスト (Self-Correction Checklist)

計画をユーザーに提示する前に、以下の質問に答えてください。

- [ ] **省略はないか？**: 「(中略)」や「以前の通り」といった記述がなく、ドキュメント単体で完結しているか？
- [ ] **その計画書だけで実装可能か？**: 計画書を見ながら、迷わずコードを書けるレベルになっているか？
- [ ] **「実際にどう動くか」が目に浮かぶか？**: UI の挙動やデータフローが具体的にイメージできるか？
- [ ] **コード断片は適切か？**: 主要な型定義や関数シグネチャが含まれているか？
- [ ] **将来の拡張に耐えうるか？**: データの正規化や責務の分離は適切に行われているか？

## 知見の継続的改善 (Continuous Knowledge Improvement)

このワークフローを使用する中で、新しい指示や改善点が見つかった場合は、必ずこのファイル (`.agent/workflows/010.md`) を更新・改善することを提案してください。
