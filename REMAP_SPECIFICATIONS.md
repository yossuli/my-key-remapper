# リマップ仕様書 (Remap Specifications)

## 概要

本ドキュメントでは、my-key-remapper におけるバックエンド（Main Process）でのリマップ処理、レイヤー管理、およびキー入力判定の仕様について記述します。

## 1. データモデル

### 1.1 トリガー (Trigger)

キー入力のパターンを以下の 3 種類に分類して扱います。

- **Tap (単押し)**: キーを押し、短期間（`HoldThreshold` 未満）で離した場合。
- **Hold (長押し)**: キーを押し、一定時間（`HoldThreshold` 以上）押し続けた場合。
- **DoubleTap (2 回押し)**: キーを放した後、一定時間（`TapInterval` 以内）に再度同じキーを押した場合。

### 1.2 アクション (Action)

トリガーに対して割り当て可能な動作です。

- **Remap**: 別のキーコードを出力します。
- **LayerToggle**: 指定したレイヤーの有効/無効を切り替えます（トグル）。
- **LayerMomentary**: キーを押している間だけ指定したレイヤーを有効にします。
- **Macro**: 事前に定義された一連のアクション（キー入力、マウス移動など）を実行します。
- **Mouse**: マウス移動やクリックを実行します。

## 2. レイヤーシステム

### 2.1 スタック構造と優先順位

レイヤーは「スタック（積み重ね）」構造で管理され、**後から追加されたレイヤー（スタックの上位）が優先**されます。

1.  **検索順序**:
    現在のスタックの上（最後尾）から順に下（先頭）へ向かって、押されたキーに対応する設定（バインディング）を探します。
2.  **有効な設定**:
    最初に見つかったバインディングが適用されます。下位レイヤーに設定があっても無視されます。
3.  **パススルー**:
    どのレイヤーにも設定がない場合は、元のキー入力がそのまま出力されます。

### 2.2 レイヤー操作

- **Push / Pop**: `LayerMomentary` などで使用され、スタックへの追加・削除を行います。
- **Reset**: 特定のレイヤー状態に強制的に戻すことができます。

## 3. 入力判定ロジック

### 3.1 判定フロー

1.  **KeyDown (押し込み)**:
    - タイマーを開始し、`Hold` か `Tap` かの判定待ち状態に入ります。
    - 既に `Tap` 判定待ち（DoubleTap 待機中）であれば、それをキャンセルして `DoubleTap` として判定する可能性があります。
2.  **Timer Fired (時間経過)**:
    - キーを離さずに `HoldThreshold` 時間が経過すると、`Hold` トリガーが確定し、アクションが実行されます。
3.  **KeyUp (離す)**:
    - 時間が経過していなければ `Tap` とみなされます。
    - ただし、`DoubleTap` の設定がある場合は、即座に発火せず `TapInterval` 時間だけ次の入力を待ちます。

### 3.2 割り込み処理 (Interruption Handling)

ユーザーが高速に入力を行った場合の挙動仕様です。

- **Hold 待機中の割り込み**:
  キー A を押し込み中（Hold 判定待ち）にキー B が押された場合、キー A の `Hold` 待ちは即座にキャンセルされ、**キー A は `Tap` として確定**されます。これにより、不自然な入力遅延を防ぎます。
- **DoubleTap 待機中の割り込み**:
  キー A の `DoubleTap` 待ち（Tap 後の待機時間）にキー B が押された場合、キー A の `DoubleTap` 待ちはキャンセルされ、**キー A は `Tap` として確定**されます。

## 4. 特殊挙動

### 4.1 パススルー (Passthrough)

リマップやレイヤー操作が設定されていないキーは、OS に対してそのままのキーコードが送信されます。

### 4.2 マクロ実行

マクロは基本的に非同期で実行されますが、順次処理（前のコマンドが終わってから次を実行）が保証されます。マクロ実行中も他のキー入力は（仕様上は）受け付けられますが、干渉を避けるためマクロ動作中は操作を控えることが推奨されます。

## 5. 高度なユースケースと仕様詳細

### 5.1 修飾キーによる条件分岐 (Conditional Remapping)

Shift や Ctrl などの修飾キーを「レイヤーの切り替えトリガー」として使用することで、修飾キー押下時の挙動を細かくカスタマイズできます。

**設定例: Shift を押したときだけ A キーで @ を入力する**

1.  **Base レイヤー**:
    - Shift キー（左右）: `LayerMomentary` アクション（`layerId: "shift"`）を設定。
2.  **Shift レイヤー**:
    - `defaultModifiers`: `{ shift: true }` を設定（レイヤー有効中は Shift が送信される）。
    - A キー: `Remap` アクション（`keys: [@]`）を設定。

### 5.2 レイヤー有効時の自動修飾キー (Default Modifiers)

レイヤー定義に `defaultModifiers` が設定されている場合、そのレイヤーがアクティブな間は該当する修飾キーが OS に対して送信され続けます（押しっぱなし状態になります）。

- この仕組みにより、リマップアクションで指定したキーも、自動的に「修飾キー + キー」として出力されます。

### 5.3 「Shift 反転」および修飾キーの打ち消し

「Shift キーを押している（Shift レイヤーが有効）が、特定のキーだけは Shift なし（小文字）で送信したい」といった特殊なケースでは、**「修飾キーを自動付与しないカスタムレイヤー」** を使用することで実現できます。

**設定例: Shift 反転（Shift 押下中に小文字 'a' を出す）**

1.  **Base レイヤー**:
    - Physical Shift キー: `LayerMomentary` (layerId: "manual_shift")
      - ※ OS に対して物理 Shift キーを通さないため、この時点では Shift は送信されません。
2.  **Manual Shift レイヤー**:
    - `defaultModifiers`: **未設定** (または `{}`)
      - ※ このレイヤーが有効になっても、自動的に Shift は送信されません。
    - **通常のキー (大文字にしたいキー)**:
      - `Remap` アクション (`keys: [VK_LSHIFT, VK_KEY]`)
      - 通常のキーはここで明示的に Shift キーと同時押しするように設定します。
    - **反転させたいキー (小文字にしたいキー)**:
      - `Remap` アクション (`keys: [VK_KEY]`)
      - Shift キーを含めずに設定することで、単独のキーのみが送信され、Shift 反転（小文字入力）が実現します。
